
import { GoogleGenAI } from "@google/genai";
import type { Settings } from '../types';

// Helper to get the AI client instance
const getAiClient = (apiKey: string) => {
  return new GoogleGenAI({ apiKey });
};

// Helper for delay
const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export const generateImage = async (prompt: string, aspectRatio: Settings['aspectRatio'], numImages: number, apiKey: string): Promise<string[]> => {
    if (!apiKey) throw new Error("API Key is required");
    
    const ai = getAiClient(apiKey);
    const generatedImages: string[] = [];
    
    // Increased max retries for free tier stability
    // Free tier is very sensitive, so we retry multiple times with long pauses
    const MAX_RETRIES = 5;
    
    try {
        // Sequential processing to respect Free Tier strict rate limits
        for (let i = 0; i < numImages; i++) {
            
            // Significant delay between images to allow quota bucket to refill
            // Free tier allows roughly 2-5 requests per minute for image generation
            // We force a long pause to stay safe.
            if (i > 0) {
                await wait(12000); // 12 seconds between images
            }

            let attempts = 0;
            let success = false;

            while (attempts < MAX_RETRIES && !success) {
                try {
                    const response = await ai.models.generateContent({
                        model: 'gemini-2.5-flash-image',
                        contents: prompt,
                        config: {
                            imageConfig: {
                                aspectRatio: aspectRatio,
                            }
                        },
                    });

                    // Extract base64 data
                    let foundImage = false;
                    for (const part of response.candidates?.[0]?.content?.parts || []) {
                        if (part.inlineData) {
                            generatedImages.push(part.inlineData.data);
                            foundImage = true;
                            success = true; 
                            break;
                        }
                    }

                    if (!foundImage) {
                         // If textual response (e.g. "I cannot generate that"), log it
                         const text = response.candidates?.[0]?.content?.parts?.find(p => p.text)?.text;
                         if (text) console.warn("Model returned text instead of image:", text);
                         
                        throw new Error("No image generated by model. The prompt might have been blocked or interpreted as text only.");
                    }

                } catch (innerError: any) {
                    attempts++;
                    
                    const errorMessage = innerError.message || String(innerError);
                    
                    // Check for various rate limit indicators
                    const isRateLimit = (
                        errorMessage.includes('429') || 
                        errorMessage.includes('Quota') ||
                        errorMessage.includes('RESOURCE_EXHAUSTED') ||
                        errorMessage.includes('Too Many Requests') ||
                        errorMessage.includes('limit')
                    );
                    
                    // Check for safety blocks - do NOT retry these
                    const isSafety = errorMessage.includes('SAFETY') || errorMessage.includes('blocked');

                    if (isSafety) {
                        throw innerError; // Fail immediately on safety
                    }

                    if (isRateLimit && attempts < MAX_RETRIES) {
                        // Exponential backoff: 
                        // Attempt 1: wait ~6s
                        // Attempt 2: wait ~11s
                        // Attempt 3: wait ~21s
                        // ...
                        const baseDelay = 5000 * Math.pow(2, attempts - 1); 
                        const jitter = Math.random() * 1500; // Add randomness to avoid thundering herd
                        const delayTime = baseDelay + jitter + 1000; // Minimum +1s extra buffer
                        
                        console.log(`Rate limit hit (Attempt ${attempts}/${MAX_RETRIES}). Cooling down for ${Math.round(delayTime/1000)}s...`);
                        await wait(delayTime);
                    } else if (isRateLimit && attempts >= MAX_RETRIES) {
                        console.error(`Failed after ${MAX_RETRIES} attempts due to rate limiting.`);
                        throw new Error("Google Free Tier Traffic Limit Exceeded. Please wait 1-2 minutes before trying again.");
                    } else {
                        // Non-rate-limit errors (network, 500, etc)
                         if (attempts < 3) {
                            console.warn(`Temporary error (Attempt ${attempts}):`, errorMessage);
                            await wait(3000);
                         } else {
                            throw innerError;
                         }
                    }
                }
            }
        }

        if (generatedImages.length > 0) {
            return generatedImages;
        } else {
            throw new Error("No images were generated.");
        }
    } catch (error: any) {
        console.error("Gemini API Error:", error);
        throw error;
    }
};

export const generateTitle = async (prompt: string, apiKey: string): Promise<string> => {
    if (!apiKey) return "Untitled Artwork";
    
    try {
        // Add a small delay to avoid hitting rate limit simultaneously with image generation completion
        await wait(1000);
        
        const ai = getAiClient(apiKey);
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash', 
            contents: `Create a single, concise, and artistic title (maximum 4 words) for an image described as: "${prompt}". No quotes.`,
        });
        return response.text?.trim().replace(/"/g, '') || "Untitled Artwork";
    } catch (error) {
        console.warn("Title generation skipped due to error (likely rate limit):", error);
        return "Untitled Artwork";
    }
};
